#load data
df1 <- read.csv("Data/combined_data_for_analysis.csv")
setwd("../")
#load data
df1 <- read.csv("Data/combined_data_for_analysis.csv")
df1$site<-factor(df1$site)
#set up one-hot coding for basin-level analysis
bas <- matrix(0, nrow = dim(df1)[1], ncol = 9)
colnames(bas) <- unique(df1$basin)
for (i in 1:dim(df1)[1])
bas[i, df1$basin[i]] <- 1
#make site-level lookup table for basin
blu <- 1:9
names(blu) <- unique(df1$basin)
bas_by_site <- blu[df1$basin[!duplicated(df1$site)]]
prov_by_site<-readRDS("Output/Results/prov_by_site.RData")
#saveRDS(bas_by_site,file = "Output/Results/basin_by_site.rds")
site<-unique(df1$site)
#### model 1: no pooling ###
no_pool <- "model{
# likelihood
for (i in 1:N){
y[i] ~ dnorm(mu[i],tau.y)
mu[i] <- alpha[site[i]]+bs[site[i]]*X[i,1]+bi[site[i]]*X[i,2]+
bh[site[i]]*X[i,3]+bx[site[i]]*X[i,1]*X[i,2]
}
# priors for site-level parameters
# site-level betas sampled from independent distributions
for(j in 1:nsite){
alpha[j]~dnorm(0,.001)
bh[j] ~ dnorm(0,.001)
bi[j] ~ dnorm(0,.001)
bs[j] ~ dnorm(0,.001)
bx[j] ~ dnorm(0,.001)
}
#prior for precision of y (land change rate)
sigma.y~dunif(0,100)
tau.y<-pow(sigma.y,-2)
}"
#load packages
library(rjags)
####compile models and take samples using 10 chains ####
##model 1
mod_1<-
jags.model(
textConnection(no_pool),
data = dat_mod1_mod2,
n.chains = 3,
n.adapt = 1000
)
#models 1 and 2 take the same input
dat_mod1_mod2 <- list(
X = data.frame(df1[, c("svi", "imp", "hurr")]),
y = df1$land_change,
N = dim(df1)[1],
nsite = length(unique(df1$site)),
site = df1$site
)
####compile models and take samples using 10 chains ####
##model 1
mod_1<-
jags.model(
textConnection(no_pool),
data = dat_mod1_mod2,
n.chains = 3,
n.adapt = 1000
)
update(mod_1, 1000)
#sample the site-level
#mod1_samples_site<-coda.samples(mod_1, c("bs", "bi", "bh","bx"), n.iter = 20000,thin = 5)
#sample predicted values
#mod1_samples_mu<-coda.samples(mod_1, "mu", n.iter = 20000,thin = 5)
#sample dic
mod1_dic <- dic.samples(model = mod_1, n.iter = 1000, type = "popt")
##model 3
mod_3<-
jags.model(
textConnection(basin_coast_pool),
data = dat_mod3,
n.chains = 3,
n.adapt = 100
)
#model 3 requires basin-scale info
dat_mod3 <- list(
X = data.frame(df1[, c(5, 3, 4)]),
y = df1$land_change,
N = dim(df1)[1],
nsite = length(unique(df1$site)),
site = df1$site,
basin = as.numeric(factor(prov_by_site)),
Nbas = 2,
sim=seq(-1,1,by=.1),
lsim=length(seq(-1,1,by=.1))
)
##model 3
mod_3<-
jags.model(
textConnection(basin_coast_pool),
data = dat_mod3,
n.chains = 3,
n.adapt = 100
)
#### model 3: site-basin-coastwide pooling ####
basin_coast_pool <- "model{
# likelihood
for (i in 1:N){
y[i] ~ dnorm(mu[i],tau.y)
mu[i] <- alpha[site[i]] + bs[site[i]]*X[i,1]+bi[site[i]]*X[i,2]+
bh[site[i]]*X[i,3]+bx[site[i]]*X[i,1]*X[i,2]
}
# priors for site-level parameters
# site-level betas sampled from basin-level distribution
for(j in 1:nsite){
alpha[j]~dnorm(0,.001)
bh[j] ~ dmnorm(b.basin.h[basin[j]],tau.basin[1])
bi[j] ~ dmnorm(b.basin.i[basin[j]],tau.basin[2])
bs[j] ~ dmnorm(b.basin.s[basin[j]],tau.basin[3])
bx[j] ~ dmnorm(b.basin.x[basin[j]],tau.basin[4])
}
#prior for precision of y
tau_y~dgamma(.1,.1)
#prior for site-level precision of betas
for(i in 1:4){
sigma.basin[i]~dunif(0,100)
tau.basin[i]<-pow(sigma.basin[i],-2)
}
# basin-level betas sampled from a coastwide distribution
for(j in 1:Nbas){
#b.basin.h[j]~dnorm(b.coast[1],tau.coast[1])
#b.basin.i[j]~dnorm(b.coast[2],tau.coast[2])
#b.basin.s[j]~dnorm(b.coast[3],tau.coast[3])
#b.basin.x[j]~dnorm(b.coast[4],tau.coast[4])
b.basin.h[j]~dnorm(0,.001)
b.basin.i[j]~dnorm(0,.001)
b.basin.s[j]~dnorm(0,.001)
b.basin.x[j]~dnorm(0,.001)
}
#prior for coastwide betas
#for(j in 1:4){
#   b.coast[j]~dnorm(0,.001)
#   sigma.coast[j]~dunif(0,100)
#   tau.coast[j]<-pow(sigma.coast[j],-2)
#}
#prior for precision of y
sigma.y~dunif(0,100)
tau.y<-pow(sigma.y,-2)
for(x in 1:lsim){
c.low[x]<-b.basin.s[1]*-1+b.basin.i[1]*sim[x]-1*sim[x]*b.basin.x[1]
c.high[x]<-b.basin.s[1]*1+b.basin.i[1]*sim[x]+1*sim[x]*b.basin.x[1]
d.low[x]<-b.basin.s[2]*-1+b.basin.i[2]*sim[x]-1*sim[x]*b.basin.x[2]
d.high[x]<-b.basin.s[2]*1+b.basin.i[2]*sim[x]+1*sim[x]*b.basin.x[2]
c.low2[x]<-b.basin.s[1]*sim[x]+b.basin.i[1]*(-1)-1*sim[x]*b.basin.x[1]
c.high2[x]<-b.basin.s[1]*sim[x]+b.basin.i[1]*(1)+1*sim[x]*b.basin.x[1]
d.low2[x]<-b.basin.s[2]*sim[x]+b.basin.i[2]*(-1)-1*sim[x]*b.basin.x[2]
d.high2[x]<-b.basin.s[2]*sim[x]+b.basin.i[2]*(1)+1*sim[x]*b.basin.x[2]
}
}"
##model 3
mod_3<-
jags.model(
textConnection(basin_coast_pool),
data = dat_mod3,
n.chains = 3,
n.adapt = 100
)
update(mod_3, 1000)
update(mod_3, 1000)
#sample the site-level
mod3_samples_site<-coda.samples(mod_3, c("bs", "bi", "bh","bx"), n.iter = 2000,thin = 1)
saveRDS(mod3_samples_site,file="Output/Results/mod3_site_samples_beta.rds")
#sample the site-level intercepts (alpha)
mod3_samples_site_alpha<-coda.samples(mod_3, c("alpha"), n.iter = 2000,thin = 1)
saveRDS(mod3_samples_site_alpha,file="Output/Results/mod3_site_samples_intercepts.rds")
#sample at the basin scale
mod3_samples_basin<-coda.samples(mod_3, c("b.basin.h","b.basin.i","b.basin.s","b.basin.x"), n.iter = 2000,thin = 1)
saveRDS(mod3_samples_basin,file="Output/Results/mod3_prov_samples.rds")
#sample at the coastwide scale
#mod3_samples_coast<-coda.samples(mod_3, "sigma.coast", n.iter = 1000,thin = 5)
#sample predicted values
mod3_samples_mu<-coda.samples(mod_3, "mu", n.iter = 2000,thin = 1)
saveRDS(mod3_samples_mu,file="Output/Results/mod3_mu_samples.rds")
#get points for the interaction plot
#mod3_samples_interaction_plot<-coda.samples(mod_3, c("c.low", "c.high", "d.low","d.high"), n.iter = 10000,thin = 5)
mod3_samples_interaction_plot<-coda.samples(mod_3, c("c.low2", "c.high2", "d.low2","d.high2"), n.iter = 2000,thin = 1)
saveRDS(mod3_samples_interaction_plot,file="Output/Results/mod3_interaction_plot.rds")
